checkout to  cassandra-1.2.0
checkout to  cassandra-1.2.1
checkout to  cassandra-1.2.2
checkout to  cassandra-1.2.3
checkout to  cassandra-1.2.4
checkout to  cassandra-1.2.5
checkout to  cassandra-1.2.6
checkout to  cassandra-1.2.7
checkout to  cassandra-1.2.8
checkout to  cassandra-1.2.9
checkout to  cassandra-1.2.10
checkout to  cassandra-2.0.0
checkout to  cassandra-2.0.1

=== cassandra-1.2.0 -> cassandra-1.2.1 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/thrift/CassandraServer.java
+ (
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/thrift/ThriftValidation.java
- ("Start token sorts after end token");
- ("exactly one of {start key, end key} or {start token, end token} must be specified");
+ ("exactly one each of {start key, start token} and {end key, end token} must be specified");
- ("start key's md5 sorts after end key's md5.  this is not allowed; you probably should not specify end key at all, under RandomPartitioner");
+ ("start key's token sorts after end key's token.  this is not allowed; you probably should not specify end key at all except with an ordered partitioner");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
- ("Only EQ and IN relation are supported on the partition key for RandomPartitioner (unless you use the token() function)");
+ ("Only EQ and IN relation are supported on the partition key for random partitioners (unless you use the token() function)");
- ("Start key sorts after end key. This is not allowed; you probably should not specify end key at all, under RandomPartitioner");
+ ("Start key sorts after end key. This is not allowed; you probably should not specify end key at all under random partitioner");
+ ("The token() function must be applied to all partition key components or none of them");
+ (String.format("Function %s is only allowed on timeuuid columns", t.function()));
+ (String.format("Partition key part %s must be restricted since preceding part is", cname));

=== cassandra-1.2.1 -> cassandra-1.2.2 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Sets.java  (file added)
+ (e.getMessage());
+ (String.format("Invalid set literal for %s of type %s", receiver, receiver.type.asCQL3Type()));
+ (String.format("Invalid set literal for %s: bind variables are not supported inside collection literals", receiver));
+ (String.format("Invalid set literal for %s: nested collections are not supported", receiver));
+ (String.format("Invalid set literal for %s: value %s is not of type %s", receiver, rt, valueSpec.type.asCQL3Type()));
+ (String.format("Invalid set literal: duplicate value %s", rt));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Constants.java  (file added)
+ (e.getMessage());
+ ("The negation of " + increment + " overflows supported counter precision (signed 8 bytes integer)");
+ (String.format("Invalid %s constant (%s) for %s of type %s", type, text, receiver, receiver.type.asCQL3Type()));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Maps.java  (file added)
+ (String.format("Invalid map literal for %s of type %s", receiver, receiver.type.asCQL3Type()));
+ (e.getMessage());
+ (String.format("Invalid map literal for %s: bind variables are not supported inside collection literals", receiver));
+ (String.format("Invalid map literal for %s: value %s is not of type %s", receiver, entry.right, valueSpec.type.asCQL3Type()));
+ (String.format("Invalid map literal for %s: nested collections are not supported", receiver));
+ (String.format("Invalid map literal for %s: key %s is not of type %s", receiver, entry.left, keySpec.type.asCQL3Type()));
+ (String.format("Invalid map literal: duplicate entry for key %s", entry.left));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/CQL3Type.java  (file added)
+ ("list type cannot contain another collection");
+ ("counters are not allowed inside a collection");
+ ("set type cannot contain another collection");
+ ("map type cannot contain another collection");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/auth/PasswordAuthenticator.java  (file added)
+ ("PasswordAuthenticator requires PASSWORD option");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/Selection.java  (file added)
+ (String.format("Cannot use selection function %s on collections", tot.isWritetime ? "writeTime" : "ttl"));
+ (String.format("Undefined name %s in selection clause", tot.id));
+ (String.format("Undefined name %s in selection clause", raw));
+ (String.format("Cannot use selection function %s on PRIMARY KEY part %s", tot.isWritetime ? "writeTime" : "ttl", name));
+ (String.format("Undefined name %s in selection clause", rawSelector));
+ (String.format("Unknown function %s called in selection clause", fun.functionName));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/functions/Functions.java  (file added)
+ (String.format("Type error: cannot assign result of function %s (type %s) to %s (type %s)", fun.name(), fun.returnType().asCQL3Type(), receiver, receiver.type.asCQL3Type()));
+ (String.format("Type error: %s cannot be passed as argument %d of function %s of type %s", provided, i, fun.name(), expected.type.asCQL3Type()));
+ (String.format("Unknown CQL3 function %s called", name));
+ (String.format("Invalid call to function %s, none of its type signature matches (known type signatures: %s)", name, signatures(factories, receiver)));
+ (String.format("Ambiguous call to function %s (can match both type signature %s and %s): use type casts to disambiguate", name, signature(candidate), signature(toTest)));
+ (String.format("Invalid number of arguments in call to function %s: %d required but %d provided", fun.name(), fun.argsType().size(), providedArgs.size()));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Operation.java  (file added)
+ (String.format("Invalid operation (%s) for non counter column %s", toString(receiver), receiver));
+ (String.format("Invalid operation (%s) for set column %s", toString(receiver), receiver));
+ (String.format("Invalid operation (%s) for non collection column %s", toString(receiver), receiver));
+ (String.format("Invalid operation (%s) for map column %s", toString(receiver), receiver));
+ (String.format("Invalid deletion operation for non collection column %s", receiver));
+ (String.format("Invalid operation (%s) for non list column %s", toString(receiver), receiver));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Lists.java  (file added)
+ (String.format("List index %d out of bound, list has size %d", idx, existingList.size()));
+ (String.format("Invalid list literal for %s: value %s is not of type %s", receiver, rt, valueSpec.type.asCQL3Type()));
+ (e.getMessage());
+ (String.format("Invalid list literal for %s of type %s", receiver, receiver.type.asCQL3Type()));
+ (String.format("Invalid list literal for %s: bind variables are not supported inside collection literals", receiver));
+ (String.format("Invalid list literal for %s: nested collections are not supported", receiver));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/TypeCast.java  (file added)
+ (String.format("Cannot cast value %s to type %s", term, type));
+ (String.format("Cannot assign value %s to %s of type %s", this, receiver, receiver.type.asCQL3Type()));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/operations/ListOperation.java  (file deleted)
- (e.getMessage());
- ("Can't apply operation on column with " + validator + " type.");
- (String.format("Invalid index %d, list has size %d", idx, list == null ? 0 : list.size()));
- ("List operations are only supported on List typed columns, but " + validator + " given.");
- (String.format("Invalid argument %s for %s, must be an integer.", value.getText(), getType()));
- (String.format("Invalid operation, %s is not of list type", column.name));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Term.java  (file deleted)
- (e.getMessage());
- ("Invalid null value for prepared variable " + bindIndex);
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/operations/ColumnOperation.java  (file deleted)
- (String.format("'%s' is an invalid value, should be a long.", value.getText()));
- ("The negation of " + val + " overflows supported integer precision (signed 8 bytes integer)");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/operations/MapOperation.java  (file deleted)
- (e.getMessage());
- ("Map operations are only supported on Map typed columns, but " + validator + " given.");
- (String.format("Invalid operation, %s is not of map type", column.name));
- ("Can't apply operation on column with " + validator + " type.");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/operations/PreparedOperation.java  (file deleted)
- ("Unsupported syntax, cannot add to a prepared set");
- ("Unsupported syntax for increment, must be of the form X = X + <value>");
- ("Unsuppoted syntax, discard syntax for map not supported");
- ("Unsupported syntax, cannot put to a prepared map");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/operations/SetOperation.java  (file deleted)
- (e.getMessage());
- ("Set operations are only supported on Set typed columns, but " + validator + " given.");
- ("Can't apply operation on column with " + validator + " type.");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/ParsedType.java  (file deleted)
- ("list type cannot contain another collection");
- ("counters are not allowed inside a collection");
- ("set type cannot contain another collection");
- ("map type cannot contain another collection");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/auth/LegacyAuthenticator.java  (file deleted)
- ("ALTER USER operation is not supported by LegacyAuthenticator");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
+ ("COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY, none given");
- (String.format("COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY (got: %s)", StringUtils.join(stmt.columns.keySet(), ", ")));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/QueryProcessor.java
+ ("Cannot execute query with bind variables");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
- ("Unknown collection type: " + validator.kind);
- (String.format("Invalid identifier %s for deletion (should not be a PRIMARY KEY part)", column));
+ (String.format("Invalid identifier %s for deletion (should not be a PRIMARY KEY part)", name));
- (String.format("Invalid selection %s since %s is neither a list or a map", column, column.id()));
- (String.format("Missing mandatory PRIMARY KEY part %s since %s specified", firstEmpty, toRemove.iterator().next().left));
+ (String.format("Missing mandatory PRIMARY KEY part %s since %s specified", firstEmpty, toRemove.iterator().next().columnName));
- (String.format("Unknown identifier %s", column));
+ (String.format("Unknown identifier %s", name));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
- ("Cannot apply collection operation on column " + name + " with " + name.type + " type.");
- ("Invalid counter operation on non-counter table.");
- ("Invalid non-counter operation on counter table.");
- ("no columns specified for INSERT");
+ ("No columns provided to INSERT");
- ("unmatched column names/values");
+ ("Unmatched column names/values");
- (String.format("Invalid definition for %s, not a collection type", name));
- (String.format("Invalid operator %s for key %s", rel.operator(), rel.getEntity()));
+ (String.format("Invalid operator %s for PRIMARY KEY part %s", rel.operator(), name));
+ (String.format("Non PRIMARY KEY %s found in where clause", name));
- (String.format("PRIMARY KEY part %s found in SET part", rel.getEntity()));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
- (String.format("Cannot use function %s on PRIMARY KEY part %s", t.function(), name));
- (String.format("Function %s is not supported on collections", t.function()));
- (String.format("Function %s is only allowed on timeuuid columns", t.function()));
- (String.format("Undefined name %s in selection clause", t.id()));
- (e.getMessage());

=== cassandra-1.2.2 -> cassandra-1.2.3 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/functions/FunctionCall.java  (file added)
+ (String.format("Invalid null value for argument to %s", fun));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Maps.java
+ ("Invalid null map key");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Operation.java
+ (String.format("Cannot set the value of counter column %s (counters can only be incremented/decremented, not set)", receiver));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/DropUserStatement.java
- (String.format("User %s doesn't exists", username));
+ (String.format("User %s doesn't exist", username));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
- (String.format("Unknown identifier %s", name));
+ (String.format("Unknown identifier %s", deletion.affectedColumn()));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
+ (String.format("Invalid null value for clustering key part %s", name));
+ (String.format("Invalid null value for partition key part %s", name));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Constants.java
+ ("Invalid null value for counter increment");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+ ("Invalid null token value");
+ (String.format("Invalid null clustering key part %s", name));
+ (String.format("Invalid null value for clustering key part %s", id));
+ (String.format("Invalid null value for partition key part %s", name));
+ (String.format("Unsupported null value for indexed column %s", name));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Lists.java
+ ("Invalid null value for list index");

=== cassandra-1.2.3 -> cassandra-1.2.4 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/Selection.java
+ (String.format("Unknown function '%s'", withFun.functionName));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Sets.java
+ ("null is not supported inside collections");
- (String.format("Invalid set literal for %s: nested collections are not supported", receiver));
+ (String.format("Set value is too long. Set values are limited to %d bytes but %d bytes value provided",
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Maps.java
+ ("null is not supported inside collections");
- (String.format("Invalid map literal for %s: nested collections are not supported", receiver));
+ (String.format("Map key is too long. Map keys are limited to %d bytes but %d bytes keys provided",
+ (String.format("Map value is too long. Map values are limited to %d bytes but %d bytes value provided",
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Constants.java
+ ("Invalid null value for counter increment/decrement");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+ (String.format("Cannot restrict PRIMARY KEY part %s by IN relation as a collection is selected by the query", cname));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Lists.java
+ ("null is not supported inside collections");
- (String.format("Invalid list literal for %s: nested collections are not supported", receiver));
+ (String.format("List value is too long. List values are limited to %d bytes but %d bytes value provided",

=== cassandra-1.2.4 -> cassandra-1.2.5 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/IndexPropDefs.java  (file added)
+ (String.format("Custom index requires '%s' option to be specified", INDEX_CLASS_KEY));
+ (String.format("Only custom indexes can currently be parametrized"));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
+ ("When upgrading from Thrift, all the columns of the (composite) clustering key must be renamed together.");
+ ("When upgrading from Thrift, all the columns of the (composite) partition key must be renamed together.");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
- (String.format("Unkown definition %s referenced in PRIMARY KEY", t));
+ (String.format("Unknown definition %s referenced in PRIMARY KEY", t));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
- (String.format("Missing mandatory PRIMARY KEY part %s since %s specified", firstEmpty, toRemove.iterator().next().columnName));
+ (String.format("Missing mandatory PRIMARY KEY part %s since %s specified", firstEmpty, toRemove.get(0).columnName));

=== cassandra-1.2.5 -> cassandra-1.2.6 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/IndexPropDefs.java  (file deleted)
- (String.format("Custom index requires '%s' option to be specified", INDEX_CLASS_KEY));
- (String.format("Only custom indexes can currently be parametrized"));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
+ ("CUSTOM index requires specifiying the index class");
+ ("Cannot specify index class for a non-CUSTOM index");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
+ (String.format("Column %s is mandatory for this COMPACT STORAGE table", cfDef.value));
- (String.format("Missing mandatory column %s", cfDef.value));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
- ("Only EQ and IN relation are supported on the partition key for random partitioners (unless you use the token() function)");
+ ("Only EQ and IN relation are supported on the partition key (you will need to use the token() function for non equality based relation)");
- (String.format("%s cannot be restricted by more than one reation if it includes a IN", name));
+ (String.format("%s cannot be restricted by more than one relation if it includes a IN", name));

=== cassandra-1.2.6 -> cassandra-1.2.7 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Sets.java
- (String.format("Invalid set literal: duplicate value %s", rt));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Maps.java
- (String.format("Invalid map literal: duplicate entry for key %s", entry.left));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/QueryProcessor.java
- (e.getMessage());
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
- ("Cannot use IN operator on column not part of the PRIMARY KEY");
+ ("Cannot use IN operator on column not part of the partition key");
- ("Start key must sort before (or equal to) finish key in your partitioner!");
- ("Start key sorts after end key. This is not allowed; you probably should not specify end key at all under random partitioner");
- (String.format("Restricting the value of a compact CF (%s) is not supported", name.name));
+ (String.format("Predicates on the non-primary-key column (%s) of a COMPACT table are not yet supported", name.name));

=== cassandra-1.2.7 -> cassandra-1.2.8 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
- ("Select using the token() function don't support IN clause");

=== cassandra-1.2.8 -> cassandra-1.2.9 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
- ("Too much columns provided for CLUSTERING ORDER");
+ ("Only clustering key columns can be defined in CLUSTERING ORDER directive");

=== cassandra-1.2.9 -> cassandra-1.2.10 ===

=== cassandra-1.2.10 -> cassandra-2.0.0 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/transport/messages/BatchMessage.java  (file added)
+ ("Cannot include non-counter statement in a counter batch");
+ ("Cannot include counter statement in a non-counter batch");
+ ("Invalid statement in batch: only UPDATE, INSERT and DELETE statements are allowed.");
+ (String.format("There were %d markers(?) in CQL but %d bound variables",
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/triggers/TriggerExecutor.java  (file added)
+ ("Counter mutations and trigger mutations cannot be applied together atomically.");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/Attributes.java  (file added)
+ ("A TTL must be greater or equal to 0");
+ ("Invalid null value of timestamp");
+ ("Invalid null value of TTL");
+ ("Invalid timestamp value");
+ (String.format("ttl is too large. requested (%d) maximum (%d)", ttl, ExpiringColumn.MAX_TTL));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java  (file added)
+ (String.format("counter type is not supported for PRIMARY KEY part %s", t.key));
+ (String.format("Multiple definition of identifier %s", entry.getElement()));
+ ("Only clustering key columns can be defined in CLUSTERING ORDER directive");
+ (String.format("COMPACT STORAGE with composite PRIMARY KEY allows no more than one column not part of the PRIMARY KEY (got: %s)", StringUtils.join(stmt.columns.keySet(), ", ")));
+ (String.format("Column family names shouldn't be more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, columnFamily()));
+ (String.format("counter type is not supported for PRIMARY KEY part %s", stmt.columnAliases.get(0)));
+ (String.format("\"%s\" is not a valid column family name (must be alphanumeric character only: [0-9A-Za-z]+)", columnFamily()));
+ ("No definition found that is not part of the PRIMARY KEY");
+ ("You must specify one and only one PRIMARY KEY");
+ ("Collection types are not supported with COMPACT STORAGE");
+ (String.format("counter type is not supported for PRIMARY KEY part %s", alias));
+ (String.format("Unknown definition %s referenced in PRIMARY KEY", t));
+ ("COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY, none given");
+ (String.format("The order of columns in the CLUSTERING ORDER directive must be the one of the clustering key (%s must appear before %s)", c, id));
+ (String.format("Missing CLUSTERING ORDER for column %s", c));
+ (String.format("Invalid collection type for PRIMARY KEY component %s", t));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/service/StorageProxy.java  (file added)
+ ("SERIAL/LOCAL_SERIAL consistency may only be requested for one row at a time");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java  (file deleted)
- (String.format("counter type is not supported for PRIMARY KEY part %s", t.key));
- (String.format("Unknown definition %s referenced in PRIMARY KEY", t));
- ("Only clustering key columns can be defined in CLUSTERING ORDER directive");
- (String.format("COMPACT STORAGE with composite PRIMARY KEY allows no more than one column not part of the PRIMARY KEY (got: %s)", StringUtils.join(stmt.columns.keySet(), ", ")));
- (String.format("Column family names shouldn't be more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, columnFamily()));
- (String.format("counter type is not supported for PRIMARY KEY part %s", stmt.columnAliases.get(0)));
- (String.format("Missing CLUSTERING ORDER for column %s", c));
- ("No definition found that is not part of the PRIMARY KEY");
- (String.format("Multiple definition of identifier %s", entry.getElement()));
- ("You must specify one and only one PRIMARY KEY");
- ("Collection types are not supported with COMPACT STORAGE");
- (String.format("\"%s\" is not a valid column family name (must be alphanumeric character only: [0-9A-Za-z]+)", columnFamily()));
- ("COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY, none given");
- (String.format("The order of columns in the CLUSTERING ORDER directive must be the one of the clustering key (%s must appear before %s)", c, id));
- (String.format("Invalid collection type for PRIMARY KEY component %s", t));
- (String.format("counter type is not supported for PRIMARY KEY part %s", alias));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/Selection.java
- (String.format("Undefined name %s in selection clause", raw));
- (String.format("Undefined name %s in selection clause", rawSelector));
+ (String.format("Undefined name %s in selection clause", raw.selectable));
+ (String.format("Undefined name %s in selection clause", rawSelector.selectable));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/thrift/CassandraServer.java
+ ("CAS does not support supercolumns");
+ ("Cross-row paging is not supported along with index clauses");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
+ ("Cannot drop columns from a non-CQL3 CF");
+ ("Cannot use collection types with Super column family");
- ("When upgrading from Thrift, all the columns of the (composite) clustering key must be renamed together.");
- ("When upgrading from Thrift, all the columns of the (composite) partition key must be renamed together.");
- (String.format("Cannot rename column %s in table %s to %s; another column of that name already exist", from, columnFamily(), to));
- (String.format("Cannot rename non PRIMARY KEY part %s", from));
- (String.format("Column %s was not found in table %s", entry.getKey(), columnFamily()));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/config/CFMetaData.java
+ (String.format("Cannot rename column %s because it is secondary indexed", strFrom));
+ (String.format("Cannot rename column %s to %s in keyspace %s; another column of that name already exist", strFrom, strTo, cfName));
+ (String.format("Cannot rename non PRIMARY KEY part %s", strFrom));
+ (String.format("Cannot rename unknown column %s in keyspace %s", strFrom, cfName));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
- (String.format("Cannot create index on PRIMARY KEY part %s", columnName));
- (String.format("Cannot create index on column %s of compact CF", columnName));
+ (String.format("Cannot add secondary index to already primarily indexed column %s", columnName));
+ (String.format("Secondary index on %s column %s is not yet supported for compact table", cd.type, columnName));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/db/ConsistencyLevel.java
+ ("Counter operations are inherently non-serializable");
+ ("Invalid consistency for conditional update. Must be one of SERIAL or LOCAL_SERIAL");
+ ("You must use conditional updates for serializable writes");
+ (this + " is not supported as conditional update commit consistency. Use ANY if you mean \"make sure it is accepted but I don't care how many replicas commit it for non-SERIAL reads\"");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
- ("A TTL must be greater or equal to 0");
+ ("Cannot provide custom timestamp for conditional update");
+ ("Conditional updates are not supported on counter tables");
+ ("Custom timestamps are not allowed when conditions are used");
+ ("IN is only supported on the last column of the partition key");
+ ("IN on the partition key is not supported with conditional updates");
+ (String.format("Invalid null value for clustering key part %s", name));
+ (String.format("Invalid null value for partition key part %s", name));
+ (String.format("Invalid operator %s for PRIMARY KEY part %s", rel.operator(), name));
+ (String.format("List operation (%s) are not allowed in conditional updates", name));
+ (String.format("Missing PRIMARY KEY part %s since %s is set", firstEmptyKey.name, name.name));
+ (String.format("Missing mandatory PRIMARY KEY part %s", name));
+ (String.format("Multiple definitions found for PRIMARY KEY part %s", name));
+ (String.format("Non PRIMARY KEY %s found in where clause", name));
+ (String.format("PRIMARY KEY part %s found in SET part", entry.left));
+ (String.format("Unknown identifier %s", entry.left));
+ (String.format("Unknown key identifier %s", rel.getEntity()));
- (String.format("ttl is too large. requested (%d) maximum (%d)", timeToLive, ExpiringColumn.MAX_TTL));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
- (String.format("Missing mandatory PRIMARY KEY part %s since %s specified", firstEmpty, toRemove.get(0).columnName));
+ (String.format("Missing mandatory PRIMARY KEY part %s since %s specified", getFirstEmptyKey(), deletions.get(0).columnName));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/QueryProcessor.java
- ("Cannot execute query with bind variables");
+ ("Invalid amount of bind variables");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
- ("IN is only supported on the last column of the partition key");
- (String.format("Invalid null value for clustering key part %s", name));
- (String.format("Invalid null value for partition key part %s", name));
- (String.format("Invalid operator %s for PRIMARY KEY part %s", rel.operator(), name));
- (String.format("Missing PRIMARY KEY part %s since %s is set", firstEmpty.name, name.name));
- (String.format("Missing mandatory PRIMARY KEY part %s", name));
- (String.format("Multiple definitions found for PRIMARY KEY part %s", name));
- (String.format("Non PRIMARY KEY %s found in where clause", name));
- (String.format("Unknown key identifier %s", rel.getEntity()));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/thrift/ThriftValidation.java
- ("Deletion does not yet support SliceRange predicates.");
- ("column name length must not be greater than " + IColumn.MAX_NAME_LENGTH);
+ ("column name length must not be greater than " + maxNameLength);
- ("supercolumn name length must not be greater than " + IColumn.MAX_NAME_LENGTH);
+ ("supercolumn name length must not be greater than " + maxNameLength);
+ (String.format("Invalid cell for CQL3 table %s. The CQL3 column component (%s) does not correspond to a defined CQL3 column",
+ (String.format("Invalid collection component, %s is not a collection", UTF8Type.instance.getString(CQL3ColumnName)));
+ (String.format("Not enough components (found %d but %d expected) for column name since %s is a CQL3 table",
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
- ("Cannot use IN operator on column not part of the partition key");
+ ("Invalid limit value");
+ ("Invalid null value of limit");
- ("Only EQ and IN relation are supported on the partition key (you will need to use the token() function for non equality based relation)");
+ ("Only EQ and IN relation are supported on the partition key (unless you use the token() function)");
+ (String.format("Aliases are not allowed in order by clause ('%s')", column));
+ (String.format("Aliases aren't allowed in where clause ('%s')", rel));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql/AlterTableStatement.java
- ("Invalid column name: "
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
- ("A TTL must be greater or equal to 0");
+ ("Conditional updates are not allowed in batches");
+ ("Invalid empty consistency level");

=== cassandra-2.0.0 -> cassandra-2.0.1 ===
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/AbstractMarker.java  (file added)
+ ("Invalid IN relation on collection column");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/Restriction.java  (file added)
+ ("Invalid null value for IN restriction");
+ (String.format("Invalid restrictions found on %s", name));
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java
+ ("Multiple PRIMARY KEYs specifed (exactly one required)");
+ ("No PRIMARY KEY specifed (exactly one required)");
- ("You must specify one and only one PRIMARY KEY");
/Users/jcwu/repos/cassandra/src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
+ ("IN restrictions are not supported on indexed columns");
+ (String.format("IN predicates on non-primary-key columns (%s) is not yet supported", name));
- (String.format("Invalid restrictions found on %s", name));
+ (String.format("SELECT DISTINCT queries must only request partition key columns (not %s)", name));
+ (String.format("SELECT DISTINCT queries must request all the partition key columns (missing %s)", name));
